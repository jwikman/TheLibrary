name: Build Linux (Full Test)

on:
  workflow_dispatch:
  workflow_call:
  push:
    paths:
      - '.github/workflows/build-linux.yml'
      - 'scripts/deploy-bc-container-local.ps1'
      - 'scripts/run-tests-odata.ps1'

env:
  AL_VERSION: 'latest'
  BCDEV_REPO: 'https://github.com/StefanMaron/BCDevOnLinux.git'
  BCDEV_BRANCH: 'v2'

jobs:
  build-linux-full-test:
    runs-on: ubuntu-latest
    name: Linux Full Test Build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Record start time
      run: |
        # Function to format bc output to ensure leading zero for decimals
        format_duration() {
            echo "$1" | sed 's/^\./0./'
        }
        START_TIME=$(date -Iseconds)
        START_EPOCH=$(date +%s.%N)
        echo "BUILD_START_TIME=$START_TIME" >> $GITHUB_ENV
        echo "BUILD_START_EPOCH=$START_EPOCH" >> $GITHUB_ENV
        echo "Build started at: $START_TIME"

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Install BC Development Tools for Linux
      run: |
        echo "Installing BC Development Tools for Linux..."
        dotnet tool install -g Microsoft.Dynamics.BusinessCentral.Development.Tools.Linux --version 17.0.28.6483-beta
        # Ensure dotnet tools are in PATH
        export PATH="$PATH:$HOME/.dotnet/tools"
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

    - name: Verify BC Development Tools installation
      run: |
        echo "Verifying BC Development Tools installation..."
        # Test al command directly (ignore exit code since al --version returns 1)
        al --version || true
        SETUP_END=$(date +%s.%N)
        SETUP_DURATION=$(echo "$SETUP_END - $BUILD_START_EPOCH" | bc -l | sed 's/^\./0./')
        echo "SETUP_DURATION=$SETUP_DURATION" >> $GITHUB_ENV
        echo "Setup (.NET + AL tools + verification) took: $SETUP_DURATION seconds"

    - name: Create dependencies directory
      run: |
        DIR_START=$(date +%s.%N)
        mkdir -p App/.alpackages
        DIR_END=$(date +%s.%N)
        DIR_DURATION=$(echo "$DIR_END - $DIR_START" | bc -l | sed 's/^\./0./')
        echo "DIR_CREATION_DURATION=$DIR_DURATION" >> $GITHUB_ENV
        echo "Directory creation took: $DIR_DURATION seconds"

    - name: Setup Docker for BC Container
      run: |
        echo "Setting up Docker environment..."
        DOCKER_SETUP_START=$(date +%s.%N)
        # Verify Docker is available
        docker --version
        docker compose version
        DOCKER_SETUP_END=$(date +%s.%N)
        DOCKER_SETUP_DURATION=$(echo "$DOCKER_SETUP_END - $DOCKER_SETUP_START" | bc -l | sed 's/^\./0./')
        echo "DOCKER_SETUP_DURATION=$DOCKER_SETUP_DURATION" >> $GITHUB_ENV
        echo "Docker setup took: $DOCKER_SETUP_DURATION seconds"

    - name: Clone BCDevOnLinux repository
      run: |
        echo "Cloning BCDevOnLinux repository..."
        CLONE_START=$(date +%s.%N)
        # Clone the repository to a temporary location
        git clone --branch ${{ env.BCDEV_BRANCH }} --depth 1 ${{ env.BCDEV_REPO }} bcdev-temp
        CLONE_END=$(date +%s.%N)
        CLONE_DURATION=$(echo "$CLONE_END - $CLONE_START" | bc -l | sed 's/^\./0./')
        echo "BCDEV_CLONE_DURATION=$CLONE_DURATION" >> $GITHUB_ENV
        echo "BCDevOnLinux clone took: $CLONE_DURATION seconds"

    - name: Pull BC Wine Base Image
      run: |
        echo "Starting container build process (including base image pull)..."
        CONTAINER_BUILD_START=$(date +%s.%N)
        echo "CONTAINER_BUILD_START=$CONTAINER_BUILD_START" >> $GITHUB_ENV
        echo "Pulling BC Wine base image..."
        BASE_IMAGE_PULL_START=$(date +%s.%N)
        # Pull the base image separately (faster than pulling during build)
        docker pull stefanmaronbc/bc-wine-base:latest
        BASE_IMAGE_PULL_END=$(date +%s.%N)
        BASE_IMAGE_PULL_DURATION=$(echo "$BASE_IMAGE_PULL_END - $BASE_IMAGE_PULL_START" | bc -l | sed 's/^\./0./')
        echo "BASE_IMAGE_PULL_DURATION=$BASE_IMAGE_PULL_DURATION" >> $GITHUB_ENV
        echo "Base image pull took: $BASE_IMAGE_PULL_DURATION seconds"

    - name: Build BC Container with Docker Compose
      run: |
        echo "Building Business Central container..."
        cd bcdev-temp
        # Build the container using docker compose
        docker compose build
        CONTAINER_BUILD_END=$(date +%s.%N)
        CONTAINER_BUILD_DURATION=$(echo "$CONTAINER_BUILD_END - $CONTAINER_BUILD_START" | bc -l | sed 's/^\./0./')
        echo "CONTAINER_BUILD_DURATION=$CONTAINER_BUILD_DURATION" >> $GITHUB_ENV
        echo "Container build took: $CONTAINER_BUILD_DURATION seconds"
        cd ..

    - name: Start BC Container
      run: |
        echo "Starting Business Central container..."
        CONTAINER_START_TIME=$(date +%s.%N)
        cd bcdev-temp
        # Start the container
        docker compose up -d
        # Wait for container to become healthy (can take up to 10 minutes)
        echo "Waiting for BC container to become healthy (this can take up to 10 minutes)..."
        CONTAINER_NAME=$(docker compose ps -q | head -n 1)
        MAX_WAIT=1200  # 20 minutes
        ELAPSED=0
        HEALTH_STATUS=""
        PREV_HEALTH_STATUS=""
        while [ $ELAPSED -lt $MAX_WAIT ]; do
            HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME 2>/dev/null || echo "unknown")
            if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "✓ BC container is healthy and ready"
                break
            fi
            # Check if container became unhealthy (was starting, now unhealthy)
            if [ "$HEALTH_STATUS" = "unhealthy" ] && [ "$PREV_HEALTH_STATUS" != "unhealthy" ]; then
                echo "⚠ Container became unhealthy - printing logs for investigation:"
                docker compose ps
                docker compose logs --tail=100
                # Also check if BC Server process is running
                echo ""
                echo "Checking BC Server process status:"
                docker compose exec -T bc pgrep -f "Microsoft.Dynamics.Nav.Server" || echo "BC Server process not found"
                echo ""
                echo "Checking initialization status:"
                docker compose exec -T bc cat /home/bc-init-status.txt 2>/dev/null || echo "No initialization status file"
            fi
            # Every 30 seconds, show more detailed status
            if [ $((ELAPSED % 30)) -eq 0 ] && [ $ELAPSED -gt 0 ]; then
                echo "Extended status check at ${ELAPSED}s:"
                echo "  Container health: $HEALTH_STATUS"
                echo "  Last 10 log lines:"
                docker compose logs --tail=10 bc
            fi
            echo "Container status: $HEALTH_STATUS (waited ${ELAPSED}s / ${MAX_WAIT}s)"
            PREV_HEALTH_STATUS="$HEALTH_STATUS"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
        done
        # Final health check after loop completes (in case timeout was reached while healthy)
        HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME 2>/dev/null || echo "unknown")
        if [ "$HEALTH_STATUS" != "healthy" ]; then
            echo "ERROR: Container did not become healthy within $MAX_WAIT seconds"
            echo "Final status: $HEALTH_STATUS"
            echo "Printing full container logs:"
            docker compose ps
            docker compose logs
            exit 1
        fi
        # Check container status
        docker compose ps
        docker compose logs
        CONTAINER_START_END=$(date +%s.%N)
        CONTAINER_START_DURATION=$(echo "$CONTAINER_START_END - $CONTAINER_START_TIME" | bc -l | sed 's/^\./0./')
        echo "CONTAINER_START_DURATION=$CONTAINER_START_DURATION" >> $GITHUB_ENV
        echo "Container start took: $CONTAINER_START_DURATION seconds"
        cd ..

    - name: Extract BC Symbol Packages from Container
      run: |
        echo "Extracting Business Central symbol packages from container filesystem..."
        EXTRACT_START=$(date +%s.%N)
        
        cd bcdev-temp
        
        # The BC artifacts are stored in /home/bcartifacts inside the container
        # Symbol files are located in the ModernDev/program files path
        echo "Locating symbol files in container..."
        
        # Find the exact path to symbol files in the container
        # They should be in /home/bcartifacts/ModernDev/program files/Microsoft Dynamics NAV/260/AL Development Environment/
        SYMBOL_PATH="/home/bcartifacts/ModernDev/program files/Microsoft Dynamics NAV/260/AL Development Environment"
        
        echo "Checking symbol path in container..."
        docker compose exec -T bc ls -la "$SYMBOL_PATH/" 2>/dev/null || {
            echo "Primary symbol path not found, searching for alternatives..."
            # Try to find symbol files anywhere in the container
            docker compose exec -T bc find /home/bcartifacts -name "*.app" -type f 2>/dev/null | head -20
            # Also check for ALLanguage location
            docker compose exec -T bc find /home/bcartifacts -type d -name "AL Development Environment" 2>/dev/null | head -5
        }
        
        # Create a helper function to copy symbol files
        copy_symbol() {
            local app_name="$1"
            local output_file="$2"
            
            echo "  → Copying $app_name symbol..."
            
            # The symbol files in BC artifacts use the format: Microsoft_<AppName>_<version>.app
            # First try to find the exact file
            local found_file
            found_file=$(docker compose exec -T bc find "$SYMBOL_PATH" -maxdepth 1 -name "Microsoft_${app_name}_*.app" -type f 2>/dev/null | head -1)
            
            if [ -n "$found_file" ]; then
                docker compose cp "bc:$found_file" "../$output_file"
                if [ -f "../$output_file" ]; then
                    local size
                    size=$(stat -c%s "../$output_file" 2>/dev/null || echo "0")
                    if [ "$size" -gt 1024 ]; then
                        echo "  ✓ $app_name copied successfully ($(numfmt --to=iec-i --suffix=B $size))"
                        return 0
                    fi
                fi
            fi
            
            echo "  ⚠ Could not find $app_name symbol file"
            return 1
        }
        
        # List available symbol files in the container for debugging
        echo ""
        echo "Available symbol files in container:"
        docker compose exec -T bc ls -la "$SYMBOL_PATH/" 2>/dev/null | grep "Microsoft_" | head -20 || echo "Could not list symbol files"
        
        # Copy required symbols for App (platform + application)
        echo ""
        echo "Copying System symbols..."
        copy_symbol "System" "App/.alpackages/System.app"
        SYSTEM_RESULT=$?

        echo ""
        echo "Copying Application symbols..."
        copy_symbol "Application" "App/.alpackages/Application.app"
        APPLICATION_RESULT=$?

        # Check if required symbols were copied
        if [ $SYSTEM_RESULT -ne 0 ] || [ $APPLICATION_RESULT -ne 0 ]; then
            echo ""
            echo "ERROR: Failed to extract required symbols (System and/or Application)"
            echo ""
            echo "Debugging: Listing all .app files in container's bcartifacts..."
            docker compose exec -T bc find /home/bcartifacts -name "*.app" -type f 2>/dev/null | head -50
            echo ""
            echo "Debugging: Container artifact structure..."
            docker compose exec -T bc ls -laR /home/bcartifacts/ModernDev/ 2>/dev/null | head -100 || echo "ModernDev path not found"
            exit 1
        fi

        # Additional symbols needed for TestApp
        echo ""
        echo "Copying test framework symbols..."
        
        copy_symbol "Library Assert" "App/.alpackages/Library Assert.app"
        copy_symbol "Any" "App/.alpackages/Any.app"
        copy_symbol "Test Runner" "App/.alpackages/Test Runner.app"
        copy_symbol "Library Variable Storage" "App/.alpackages/Library Variable Storage.app"

        cd ..

        EXTRACT_END=$(date +%s.%N)
        EXTRACT_DURATION=$(echo "$EXTRACT_END - $EXTRACT_START" | bc -l | sed 's/^\./0./')
        echo "SYMBOL_EXTRACT_DURATION=$EXTRACT_DURATION" >> $GITHUB_ENV
        echo "BC symbol extraction took: $EXTRACT_DURATION seconds"

        # List all symbols in .alpackages
        echo ""
        echo "Extracted symbol packages in App/.alpackages:"
        ls -lah App/.alpackages/
        
        # Count and verify required symbols (System and Application are mandatory)
        echo ""
        if [ -f "App/.alpackages/System.app" ] && [ -f "App/.alpackages/Application.app" ]; then
            SYSTEM_SIZE=$(stat -c%s "App/.alpackages/System.app" 2>/dev/null || echo "0")
            APP_SIZE=$(stat -c%s "App/.alpackages/Application.app" 2>/dev/null || echo "0")
            if [ "$SYSTEM_SIZE" -gt 1024 ] && [ "$APP_SIZE" -gt 1024 ]; then
                echo "✓ Required symbols extracted successfully"
            else
                echo "ERROR: Required symbol files are empty or too small"
                exit 1
            fi
        else
            echo "ERROR: Missing required symbols (System and Application)"
            exit 1
        fi

    - name: Pre-compilation setup
      run: |
        SETUP_START=$(date +%s.%N)
        # No bin directory needed - AL compiler outputs to project root by default
        SETUP_END=$(date +%s.%N)
        SETUP_DURATION=$(echo "$SETUP_END - $SETUP_START" | bc -l | sed 's/^\./0./')
        echo "PRECOMPILE_SETUP_DURATION=$SETUP_DURATION" >> $GITHUB_ENV
        echo "Pre-compilation setup: $SETUP_DURATION seconds"

        # Set dependency duration variables for metrics
        echo "SYSTEM_DOWNLOAD_DURATION=0" >> $GITHUB_ENV
        echo "SYSTEM_EXTRACT_DURATION=$SYMBOL_EXTRACT_DURATION" >> $GITHUB_ENV
        echo "BASE_DOWNLOAD_DURATION=0" >> $GITHUB_ENV
        echo "BASE_EXTRACT_DURATION=0" >> $GITHUB_ENV
        TOTAL_DEP_TIME=$(echo "$SYMBOL_EXTRACT_DURATION" | bc -l | sed 's/^\./0./')
        echo "TOTAL_DEPENDENCY_DURATION=$TOTAL_DEP_TIME" >> $GITHUB_ENV
        echo "Total dependency handling: $TOTAL_DEP_TIME seconds"

    - name: Compile AL Extension
      run: |
        echo "Compiling AL extension..."
        COMPILE_START=$(date +%s.%N)

        # Compile the App folder
        if al compile /project:"App" /packagecachepath:"App/.alpackages"; then
            echo "App compilation successful"
        else
            echo "App compilation failed with exit code: $?"
            exit 1
        fi

        # Prepare TestApp dependencies - copy all symbol packages from App
        mkdir -p TestApp/.alpackages
        echo "Copying all symbol packages to TestApp/.alpackages..."
        cp App/.alpackages/*.app TestApp/.alpackages/

        # Copy the compiled main app to TestApp dependencies
        echo "Copying compiled main app to TestApp/.alpackages..."
        cp App/*.app TestApp/.alpackages/

        # List what's available for TestApp compilation
        echo "TestApp dependencies:"
        ls -la TestApp/.alpackages/

        # Compile the TestApp folder
        if al compile /project:"TestApp" /packagecachepath:"TestApp/.alpackages"; then
            echo "TestApp compilation successful"
        else
            echo "TestApp compilation failed with exit code: $?"
            exit 1
        fi

        COMPILE_END=$(date +%s.%N)
        COMPILE_DURATION=$(echo "$COMPILE_END - $COMPILE_START" | bc -l | sed 's/^\./0./')
        echo "COMPILE_DURATION=$COMPILE_DURATION" >> $GITHUB_ENV
        echo "Compilation took: $COMPILE_DURATION seconds"

    - name: Post-compilation analysis
      run: |
        ANALYSIS_START=$(date +%s.%N)
        # List and analyze compiled files
        echo "Compiled files:"
        echo "App folder:"
        find App -maxdepth 1 -type f -name "*.app" | while read file; do
            SIZE_BYTES=$(stat -c%s "$file" 2>/dev/null || echo "0")
            SIZE_KB=$(echo "scale=2; $SIZE_BYTES / 1024" | bc -l | sed 's/^\./0./')
            echo "  $(basename "$file") - ${SIZE_KB} KB"
        done
        echo "TestApp folder:"
        find TestApp -maxdepth 1 -type f -name "*.app" | while read file; do
            SIZE_BYTES=$(stat -c%s "$file" 2>/dev/null || echo "0")
            SIZE_KB=$(echo "scale=2; $SIZE_BYTES / 1024" | bc -l | sed 's/^\./0./')
            echo "  $(basename "$file") - ${SIZE_KB} KB"
        done
        # Count apps and calculate total size
        APP_COUNT=$(find App TestApp -maxdepth 1 -type f -name "*.app" | wc -l)
        if [ "$APP_COUNT" -gt 0 ]; then
            TOTAL_SIZE_BYTES=$(find App TestApp -maxdepth 1 -type f -name "*.app" -exec stat -c%s {} + 2>/dev/null | awk '{sum+=$1} END {print sum}' || echo "0")
            TOTAL_SIZE_KB=$(echo "scale=2; $TOTAL_SIZE_BYTES / 1024" | bc -l | sed 's/^\./0./')
            echo "APP_COUNT=$APP_COUNT" >> $GITHUB_ENV
            echo "TOTAL_APP_SIZE_KB=$TOTAL_SIZE_KB" >> $GITHUB_ENV
            echo "Total app size: ${TOTAL_SIZE_KB} KB"
        fi
        ANALYSIS_END=$(date +%s.%N)
        ANALYSIS_DURATION=$(echo "$ANALYSIS_END - $ANALYSIS_START" | bc -l | sed 's/^\./0./')
        echo "POST_COMPILE_ANALYSIS_DURATION=$ANALYSIS_DURATION" >> $GITHUB_ENV
        echo "Post-compilation analysis: $ANALYSIS_DURATION seconds"

    - name: Publish AL Extension to Container
      run: |
        echo "Publishing AL extensions to BC container..."
        PUBLISH_START=$(date +%s.%N)

        # Publish the main App
        APP_FILE=$(find App -maxdepth 1 -name "*.app" -type f | head -n 1)
        if [ -z "$APP_FILE" ]; then
            echo "ERROR: No app file found for publishing"
            exit 1
        fi
        echo "Publishing main app: $APP_FILE"
        curl -u "admin:Admin123!" \
             -F "file=@$APP_FILE" \
             "http://localhost:7049/BC/dev/apps?tenant=default&SchemaUpdateMode=synchronize&DependencyPublishingOption=default"

        echo ""
        echo "Waiting 5 seconds before publishing TestApp..."
        sleep 5

        # Publish the TestApp
        TEST_APP_FILE=$(find TestApp -maxdepth 1 -name "*.app" -type f | head -n 1)
        if [ -z "$TEST_APP_FILE" ]; then
            echo "ERROR: No test app file found for publishing"
            exit 1
        fi
        echo "Publishing test app: $TEST_APP_FILE"
        curl -u "admin:Admin123!" \
             -F "file=@$TEST_APP_FILE" \
             "http://localhost:7049/BC/dev/apps?tenant=default&SchemaUpdateMode=synchronize&DependencyPublishingOption=default"

        PUBLISH_END=$(date +%s.%N)
        PUBLISH_DURATION=$(echo "$PUBLISH_END - $PUBLISH_START" | bc -l | sed 's/^\./0./')
        echo "PUBLISH_DURATION=$PUBLISH_DURATION" >> $GITHUB_ENV
        echo "Publishing took: $PUBLISH_DURATION seconds"

    - name: Verify BC User for API Testing
      run: |
        echo "=== COMPREHENSIVE BC TROUBLESHOOTING ==="
        TROUBLESHOOT_START=$(date +%s.%N)
        cd bcdev-temp

        # 1. Check environment variables that BCDevOnLinux uses
        echo ""
        echo "1. Checking BCDevOnLinux environment variables..."
        docker compose exec -T bc printenv | grep -i password || echo "No password environment variables found"
        docker compose exec -T bc printenv | grep -i admin || echo "No admin environment variables found"

        # 2. Check BC Server version and configuration (COMPLETE DUMP)
        echo ""
        echo "2. Checking BC Server configuration..."
        echo "=========================================="
        echo "COMPLETE CustomSettings.config:"
        echo "=========================================="
        docker compose exec -T bc cat /BC/Service/CustomSettings.config 2>/dev/null || echo "Could not read CustomSettings.config"
        echo "=========================================="
        echo ""
        echo "IMPORTANT: ClientServicesCredentialType should be 'NavUserPassword' for username/password auth on OData"
        echo "IMPORTANT: ODataServicesEnabled should be 'true' for OData to work"

        # 3. Verify admin user exists and check authentication mode
        echo ""
        echo "3. Checking BC users in database..."
        docker compose exec -T sql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "P@ssw0rd123!" -d BC -Q "SELECT [User Name], [User Security ID], State, [License Type], [Authentication Email] FROM [dbo].[User]" -C -N || echo "Failed to query users"

        # 4. Check User Property for admin user (including password hash)
        echo ""
        echo "4. Checking admin user properties..."
        docker compose exec -T sql /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "P@ssw0rd123!" -d BC -Q "SELECT [User Security ID], [User Name], [Password] FROM [dbo].[User] WHERE [User Name] = 'admin'" -C -N || echo "Failed to query admin user properties"

        # 5. Test API endpoints accessibility
        echo ""
        echo "5. Testing API endpoint accessibility (no auth)..."
        curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" "http://localhost:7048/BC/api/v2.0/\$metadata" 2>&1
        curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" "http://localhost:7048/BC/api/v2.0/companies" 2>&1

        # 6. Test multiple password combinations (non-blocking)
        echo ""
        echo "6. Testing API access with different password combinations..."

        # Array of passwords to test
        PASSWORDS=("Admin123!" "admin" "Admin123" "YourStrong!Passw0rd" "" "P@ssw0rd")

        for PASS in "${PASSWORDS[@]}"; do
            if [ -z "$PASS" ]; then
                echo "  Testing with no password..."
                RESULT=$(curl -s -u "admin:" -o /dev/null -w "%{http_code}" "http://localhost:7048/BC/api/v2.0/companies" 2>&1)
            else
                echo "  Testing password: $PASS"
                RESULT=$(curl -s -u "admin:$PASS" -o /dev/null -w "%{http_code}" "http://localhost:7048/BC/api/v2.0/companies" 2>&1)
            fi
            echo "    Result: HTTP $RESULT"

            # If we get 200, show success and the first company
            if [ "$RESULT" = "200" ]; then
                echo "    ✓ SUCCESS! Password works: $PASS"
                echo "    First company data:"
                curl -s -u "admin:$PASS" "http://localhost:7048/BC/api/v2.0/companies" 2>&1 | head -10
                echo "WORKING_PASSWORD=$PASS" >> $GITHUB_ENV
                break
            fi
        done

        # 7. Check BC Server logs for authentication errors
        echo ""
        echo "7. Checking BC Server logs for authentication errors..."
        docker compose exec -T bc tail -50 /home/bc-init.log 2>/dev/null | grep -i -E "error|auth|password|user" || echo "No relevant log entries found"

        # 8. Verify Web Services are enabled
        echo ""
        echo "8. Checking if OData web services are accessible..."
        curl -v "http://localhost:7048/BC/api/v2.0/\$metadata" 2>&1 | grep -E "HTTP/|OData|<?xml" | head -20

        # 9. Check BC container processes
        echo ""
        echo "9. Checking BC Server process details..."
        docker compose exec -T bc ps aux | grep -i "dynamics\|service" || echo "No BC processes found"

        # 10. Check port bindings
        echo ""
        echo "10. Verifying port bindings..."
        docker compose ps
        echo ""
        echo "Testing localhost connectivity to ports:"
        for PORT in 7046 7047 7048 7049; do
            nc -zv localhost $PORT 2>&1 | grep -E "succeeded|open|Connected" && echo "  Port $PORT: OPEN" || echo "  Port $PORT: CLOSED"
        done

        # 11. Check BC Server service status (if systemd or similar)
        echo ""
        echo "11. Checking BC service status inside container..."
        docker compose exec -T bc bash -c "ls -la /BC/Service/" 2>/dev/null | head -20 || echo "Could not list BC Service directory"

        # 12. Final summary
        echo ""
        echo "=== TROUBLESHOOTING COMPLETE ==="
        if [ -n "$WORKING_PASSWORD" ]; then
            echo "✓ Working password found: $WORKING_PASSWORD"
        else
            echo "✗ No working password found - authentication will likely fail"
        fi

        TROUBLESHOOT_END=$(date +%s.%N)
        TROUBLESHOOT_DURATION=$(echo "$TROUBLESHOOT_END - $TROUBLESHOOT_START" | bc -l | sed 's/^\./0./')
        echo ""
        echo "Troubleshooting diagnostics took: $TROUBLESHOOT_DURATION seconds"

        cd ..

    - name: Run AL Tests in Container via OData
      run: |
        echo "Running AL tests in BC container via OData API..."
        TEST_START=$(date +%s.%N)

        # Use the discovered working password if available, otherwise use default
        if [ -n "$WORKING_PASSWORD" ]; then
            echo "Using discovered working password: $WORKING_PASSWORD"
            TEST_PASSWORD="$WORKING_PASSWORD"
        else
            echo "Using default password (Admin123!)"
            TEST_PASSWORD="Admin123!"
        fi

        # Execute test codeunit via OData API using PowerShell script
        # Running Library Author Tests (codeunit 70451)
        # Port mappings: 7046=WebClient, 7047=SOAP, 7048=OData/API, 7049=Development
        pwsh ./scripts/run-tests-odata.ps1 \
          -BaseUrl "http://localhost:7048/BC" \
          -Tenant "default" \
          -Username "admin" \
          -Password "$TEST_PASSWORD" \
          -CodeunitId 70451 \
          -MaxWaitSeconds 300
        TEST_EXIT_CODE=$?

        TEST_END=$(date +%s.%N)
        TEST_DURATION=$(echo "$TEST_END - $TEST_START" | bc -l | sed 's/^\./0./')
        echo "TEST_DURATION=$TEST_DURATION" >> $GITHUB_ENV
        echo "Testing took: $TEST_DURATION seconds"

        # Exit with the test script's exit code
        exit $TEST_EXIT_CODE

    - name: Calculate comprehensive build metrics
      run: |
        END_TIME=$(date -Iseconds)
        END_EPOCH=$(date +%s.%N)
        TOTAL_DURATION=$(echo "$END_EPOCH - $BUILD_START_EPOCH" | bc -l | sed 's/^\./0./')
        echo "=== LINUX FULL BUILD & TEST PERFORMANCE SUMMARY ==="
        echo "Build Start Time: $BUILD_START_TIME"
        echo "Build End Time: $END_TIME"
        echo ""
        echo "=== DETAILED TIMINGS ==="
        echo "Setup (.NET + AL tools): $SETUP_DURATION seconds"
        echo "Directory Creation: $DIR_CREATION_DURATION seconds"
        echo "System App Download: $SYSTEM_DOWNLOAD_DURATION seconds"
        echo "System App Extract: $SYSTEM_EXTRACT_DURATION seconds"
        echo "Base App Download: $BASE_DOWNLOAD_DURATION seconds"
        echo "Base App Extract: $BASE_EXTRACT_DURATION seconds"
        echo "Total Dependencies: $TOTAL_DEPENDENCY_DURATION seconds"
        echo "Pre-compile Setup: $PRECOMPILE_SETUP_DURATION seconds"
        echo "Compilation: $COMPILE_DURATION seconds"
        echo "Post-compile Analysis: $POST_COMPILE_ANALYSIS_DURATION seconds"
        echo "Docker Setup: $DOCKER_SETUP_DURATION seconds"
        echo "BCDev Clone: $BCDEV_CLONE_DURATION seconds"
        echo "Container Build: $CONTAINER_BUILD_DURATION seconds"
        echo "Container Start: $CONTAINER_START_DURATION seconds"
        echo "Publishing: $PUBLISH_DURATION seconds"
        echo "Testing: $TEST_DURATION seconds"
        echo ""
        echo "=== BUILD SUMMARY ==="
        echo "Total Build Time: $TOTAL_DURATION seconds"
        if [ -n "$APP_COUNT" ]; then echo "Apps Generated: $APP_COUNT"; fi
        if [ -n "$TOTAL_APP_SIZE_KB" ]; then echo "Total App Size: $TOTAL_APP_SIZE_KB KB"; fi
        if [ -n "$TEST_FILE_COUNT" ]; then echo "Test Files Found: $TEST_FILE_COUNT"; fi
        # Create comprehensive JSON metrics for external analysis
        cat > linux-full-test-metrics.json << EOF
        {
          "platform": "linux-full-test",
          "runner_os": "ubuntu-latest",
          "total_duration": $TOTAL_DURATION,
          "setup_duration": ${SETUP_DURATION:-0},
          "dir_creation_duration": ${DIR_CREATION_DURATION:-0},
          "system_download_duration": ${SYSTEM_DOWNLOAD_DURATION:-0},
          "system_extract_duration": ${SYSTEM_EXTRACT_DURATION:-0},
          "base_download_duration": ${BASE_DOWNLOAD_DURATION:-0},
          "base_extract_duration": ${BASE_EXTRACT_DURATION:-0},
          "total_dependency_duration": ${TOTAL_DEPENDENCY_DURATION:-0},
          "precompile_setup_duration": ${PRECOMPILE_SETUP_DURATION:-0},
          "compile_duration": ${COMPILE_DURATION:-0},
          "post_compile_analysis_duration": ${POST_COMPILE_ANALYSIS_DURATION:-0},
          "docker_setup_duration": ${DOCKER_SETUP_DURATION:-0},
          "bcdev_clone_duration": ${BCDEV_CLONE_DURATION:-0},
          "container_build_duration": ${CONTAINER_BUILD_DURATION:-0},
          "container_start_duration": ${CONTAINER_START_DURATION:-0},
          "publish_duration": ${PUBLISH_DURATION:-0},
          "test_duration": ${TEST_DURATION:-0},
          "app_count": ${APP_COUNT:-0},
          "total_app_size_kb": ${TOTAL_APP_SIZE_KB:-0},
          "test_file_count": ${TEST_FILE_COUNT:-0},
          "timestamp": "$END_TIME",
          "uses_container": true,
          "pipeline_type": "full-test",
          "measurement_precision": "nanoseconds",
          "github_run_id": "${GITHUB_RUN_ID:-unknown}",
          "github_run_number": "${GITHUB_RUN_NUMBER:-unknown}",
          "github_sha": "${GITHUB_SHA:-unknown}"
        }
        EOF
        echo "Comprehensive metrics saved to linux-full-test-metrics.json"
        # Also create a raw measurements file for detailed analysis
        cat > linux-full-test-raw-measurements.json << EOF
        {
          "build_id": "${GITHUB_RUN_ID:-unknown}-${GITHUB_RUN_NUMBER:-unknown}",
          "platform": "linux",
          "runner": "ubuntu-latest",
          "pipeline_type": "full-test",
          "start_time": "$BUILD_START_TIME",
          "end_time": "$END_TIME",
          "measurements": [
            {"stage": "setup", "duration": ${SETUP_DURATION:-0}, "unit": "seconds"},
            {"stage": "dir_creation", "duration": ${DIR_CREATION_DURATION:-0}, "unit": "seconds"},
            {"stage": "system_download", "duration": ${SYSTEM_DOWNLOAD_DURATION:-0}, "unit": "seconds"},
            {"stage": "system_extract", "duration": ${SYSTEM_EXTRACT_DURATION:-0}, "unit": "seconds"},
            {"stage": "base_download", "duration": ${BASE_DOWNLOAD_DURATION:-0}, "unit": "seconds"},
            {"stage": "base_extract", "duration": ${BASE_EXTRACT_DURATION:-0}, "unit": "seconds"},
            {"stage": "precompile_setup", "duration": ${PRECOMPILE_SETUP_DURATION:-0}, "unit": "seconds"},
            {"stage": "compile", "duration": ${COMPILE_DURATION:-0}, "unit": "seconds"},
            {"stage": "post_compile_analysis", "duration": ${POST_COMPILE_ANALYSIS_DURATION:-0}, "unit": "seconds"},
            {"stage": "docker_setup", "duration": ${DOCKER_SETUP_DURATION:-0}, "unit": "seconds"},
            {"stage": "bcdev_clone", "duration": ${BCDEV_CLONE_DURATION:-0}, "unit": "seconds"},
            {"stage": "container_build", "duration": ${CONTAINER_BUILD_DURATION:-0}, "unit": "seconds"},
            {"stage": "container_start", "duration": ${CONTAINER_START_DURATION:-0}, "unit": "seconds"},
            {"stage": "publish", "duration": ${PUBLISH_DURATION:-0}, "unit": "seconds"},
            {"stage": "test", "duration": ${TEST_DURATION:-0}, "unit": "seconds"}
          ],
          "totals": {
            "total_duration": $TOTAL_DURATION,
            "dependency_total": ${TOTAL_DEPENDENCY_DURATION:-0},
            "container_total": $(echo "${DOCKER_SETUP_DURATION:-0} + ${BCDEV_CLONE_DURATION:-0} + ${CONTAINER_BUILD_DURATION:-0} + ${CONTAINER_START_DURATION:-0}" | bc -l | sed 's/^\./0./')
          },
          "artifacts": {
            "app_count": ${APP_COUNT:-0},
            "total_app_size_kb": ${TOTAL_APP_SIZE_KB:-0},
            "test_file_count": ${TEST_FILE_COUNT:-0}
          },
          "environment": {
            "github_actions": true,
            "runner_os": "Linux",
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: linux-full-test-artifacts
        path: |
          App/*.app
          TestApp/*.app
          linux-full-test-metrics.json
          linux-full-test-raw-measurements.json
        retention-days: 30
    - name: Display system information
      run: |
        echo "=== SYSTEM INFORMATION ==="
        echo "OS: $(lsb_release -d | cut -f2)"
        echo "Kernel: $(uname -r)"
        echo "CPU: $(nproc) cores"
        echo "Memory: $(free -h | grep Mem | awk '{print $2}')"
        echo "Disk: $(df -h . | tail -1 | awk '{print $4}') available"
        echo "Docker: $(docker --version)"
